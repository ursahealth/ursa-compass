interrogation_playbook:
  goal: Understand structure, content, identifiers, payment conventions, and data generation process of incoming MMR data.
  steps:
    - step: identify_patient_and_plan_information
      goal: Determine patient and plan identifiers and locate other useful demographic/status fields.
      checks:
        - check: Identify potential patient identifier fields (e.g., member_id, mbi). Note consistency and population rate. Determine primary source_local_patient_id candidate.
        - check: Identify potential plan identifier fields (contract_number, pbp_number, segment_id). Note population consistency.
        - check: Determine if plan identifier fields accurately reflect the plan structure (e.g., Contract+PBP vs Contract+PBP+Segment). Note potential need to simplify plan ID construction later.
        - check: Identify key patient status fields (hospice_indicator, esrd_indicator, raf_type_code, original/current_eligibility_reason_code, medicaid_status). Note their values and consistency.
        - check: Identify demographic fields if present (dob, gender - often less common in MMR than eligibility files).

    - step: identify_core_mmr_fields_and_dates
      goal: Locate key fields describing risk scores, payments, and timing.
      checks:
        - check: Identify the two key time dimensions
            - Covered Period / Incurred Month (Often payment_adjustment_start_date and payment_adjustment_end_date). Note if provided as spans or already monthly.
            - Payment Period / Report Month (Often payment_date or similar).
        - check: Locate RAF score fields (e.g., risk_adjustment_factor_a_b, risk_adjustment_factor_d).
        - check: Locate Payment Amount fields (e.g., total_ma_payment_amount_part_c, total_ma_payment_amount_part_d, risk_adjusted_paid_amount_part_a/b).
        - check: Locate Rebate fields (e.g., rebate_part_d_basic_premium_reduction).
        - check: Locate Adjustment Reason Code field(s). Profile distinct values.
        - check: Locate fields indicating the number of payment months covered by a record if spans exist (e.g., num_payment_adjustment_months_a_b, num_payment_adjustment_months_d).
        - check: Check if data distinguishes Part C vs Part D explicitly, or if they are combined in single rows.

    - step: determine_transactionality_and_conventions
      goal: Confirm MMR data is transactional and determine payment conventions.
      method:
        - type: case_review
          sort_by: [patient_id, covered_period_start_date, payment_date, contract_id, pbp_id] # Or similar key combination
          display_fields: [patient_id, covered_period_start_date, payment_date, raf_score_a_b, payment_amount_part_c, adjustment_reason_code, hospice_indicator, plan_fields]
          row_limit: 100 # Review multiple months for a patient
      checks:
        - check: Confirm transactional nature by observing changes to the same incurred month across different payment dates/report months. Look for retroactive changes.
        - check: Determine payment convention (Resultant vs. Increase-to).
            - Standard MMR is typically 'Increase-to'. Look for negative payment amounts correlating with decreases in RAF scores or specific adjustment reason codes (e.g., reversals, retroactive disenrollment).
            - If only positive values and changing RAF scores are present, it might be 'Resulting' or a payer-curated final action file (less common for true MMR).
        - check: Assess consistency of the convention. Does it apply to all payment fields similarly?
        - check: Note any confusing scenarios, like zero payments when RAF score changes, or non-zero payments with hospice indicators.
        - check: Check if Adjustment Reason Codes align with payment changes (e.g., does code '03' - Retroactive Disenrollment correspond to a negative payment amount?).

    - step: identify_keys_and_grain
      goal: Define the appropriate keys for tracking transactions and final action states.
      checks:
        - check: Define the 'Transaction Family' key. This identifies a specific patient-plan-incurred_month combination that is being updated over time. Usually [patient_id] + [plan_id (Contract+PBP)] + [covered_period_start_date].
        - check: Define the 'Transaction' key. This uniquely identifies a specific update within a family. Usually [Transaction Family Key] + [payment_date]. Check if additional fields like adjustment_reason_code or internal sequence numbers are needed for uniqueness, especially if multiple updates occur in the same payment month.
        - check: Assess if the source provides a reliable transaction sequence number. If not, plan to derive one based on payment_date and potentially adjustment_reason_code logic (e.g., reversals happen before adjustments on the same day).
        - check: Determine the final desired grain for analysis (usually Patient-Plan-Month). Note if the source data needs to be 'chunked' from spans into months.

    - step: assess_data_quality_and_consistency
      goal: Identify potential issues specific to MMR data.
      checks:
        - check: Check for unexpected nulls in key fields (IDs, dates, RAF scores, payment amounts for active months).
        - check: Check consistency between status flags and financial values (e.g., Hospice status should generally correspond to zero RAF-based payments, but check adjustment reason codes).
        - check: Verify consistency of Plan IDs (Contract/PBP/Segment) across records for the same patient/month/payment date. Note if segment numbers cause apparent plan changes that should be handled differently.
        - check: Assess alignment between MMR records and separate Membership/Eligibility files if available (this happens during interleaving but initial checks are useful). Are patients present in MMR but missing from eligibility, or vice versa?

    - step: understand_data_generating_process_revisited
      goal: Solidify understanding of how MMR data arrives and potential payer modifications.
      checks:
        - check: Confirm if data appears to be standard CMS MMR (transactional, increase-to, dual time dimensions) or a payer-modified version (potentially restated, resulting, final action, curated/filtered transactions).
        - check: If restated, assess how terminations/disenrollments are handled (silenced records vs. explicit transactions). Determine if complex restatement logic ("Cadillac") is needed.
        - check: Identify the look-back period if restated. Is it fixed, rolling, or have step-changes?
        - check: Note any evidence of data curation (e.g., missing intermediate payment months, monthly chunking already performed).
