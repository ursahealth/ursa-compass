playbook:
  goal: Understand structure, content, identifiers, and data generation process of incoming medical claims data.
  steps:
    - step: identify_patient_information
      goal: Determine primary patient identifier and locate other useful demographic fields.
      checks:
        - check: Identify potential patient identifier fields (e.g., member_id, patient_id, mbi, ssn).
        - check: Assess reliability and population consistency of identifier fields.
        - check: Determine primary source_local_patient_id candidate.
        - check: Note presence and overlap of multiple identifiers (e.g., Member ID and MBI).
        - check: Identify demographic fields (dob, gender, zip, state) and note formats/completeness.
        - check: Determine state code format (FIPS, SSA, Postal).

    - step: identify_core_service_and_date_fields
      goal: Locate key fields describing the service provided and its timing.
      checks:
        - check: Identify available date fields (service_date, claim_from/thru_date, admission/discharge_date, paid_date, transaction_date, report_date, last_updated_date).
        - check: Note date mask formats for all date fields.
        - check: Verify consistency of service line dates within header dates.
        - check: Locate procedure code fields (HCPCS/CPT) and modifier fields.
        - check: Locate diagnosis code fields (ICD-10-CM).
        - check: Check diagnosis storage format (wide vs. long).
        - check: Check for presence of POA flags (Institutional).
        - check: Check for Principal Diagnosis indicators (explicit flag vs. position).
        - check: Check for Admitting Diagnosis.
        - check: Check for DRG codes (especially MS-DRG) possibly within diagnosis arrays.
        - check: Verify ICD-10-CM code format (e.g., decimal presence).
        - check: Locate Institutional-specific fields (type_of_bill, revenue_center_code).
        - check: Locate Professional-specific fields (place_of_service).

    - step: distinguish_institutional_vs_professional
      goal: Determine how to reliably identify claim type (Institutional vs. Professional).
      checks:
        - check: Determine if claim types are in separate source tables.
        - check: Check for an explicit claim_type_code field and its distinct values (e.g., 'I', 'P', 'institutional', 'professional').
          query: |
            select distinct claim_type_code
            from my_claims_table
            limit 20
        - check: Check presence and population of type_of_bill codes (indicative of Institutional).
        - check: Check presence and population of facility_type_code or place_of_service codes (indicative of Professional).
        - check: Verify harmonization between different indicators if multiple exist.
          query_inst_fac_conflict: |
            select count(*) as should_be_zero
            from my_claims_table
            where claim_type_code = 'I' -- Or equivalent institutional code
            and fac_type_code is not null
            and fac_type_code <> ''
          query_prof_tob_conflict: |
            select count(*) as should_be_zero
            from my_claims_table
            where claim_type_code = 'P' -- Or equivalent professional code
            and bill_type_code is not null
            and bill_type_code <> ''
        - check: Decide on the most reliable field(s) to determine claim class.

    - step: determine_transactionality_and_identify_keys
      goal: Understand if data is final action or transactional, and identify Claim ID, Line ID, and Transaction ID.
      method:
        - type: case_review
          sort_by: [patient_id, date_of_service, procedure_code, potential_claim_id, line_number (numeric), transaction_date]
          display_fields: [patient_id, date_of_service, procedure_code, potential_claim_id, line_number, transaction_date, paid_amount, status_flags]
          row_limit: 50 # Initial review
      checks:
        - check: Evaluate behavior of potential claim_id field across rows for the same service event. Note if it changes frequently (suggests transaction ID) or remains stable (suggests claim ID).
        - check: Evaluate behavior of line_number field (gaps, duplicates, non-numeric, starts at 1?). Consider need for regeneration.
        - check: Determine if multiple rows exist per claim line (indicates transactional).
        - check: Identify reliable sequencing date (transaction_date, report_date, paid_date, last_updated_date).
        - check: Define construction logic for stable source_local_claim_id.
        - check: Define construction logic for source_local_claim_service_line_item_id (e.g., claim_id + reliable_line_number).
        - check: Define construction logic for transaction_id if data is transactional (e.g., claim_id + line_number + transaction_date).
      hypothesis_testing:
        - test: resultant_vs_increase_to
          goal: If transactional, determine adjustment convention.
          checks:
            - check: Presence of negative paid_amount values (suggests increase-to).
            - check: Mathematical consistency of transaction sequences (reversals/adjustments netting out).
            - check: Identify potential inconsistent conventions or data quality issues (e.g., zeros masking prior values).
        - test: primary_keys_and_duplicates
          goal: Validate assumed identifiers across the full dataset.
          queries:
            - name: check_transaction_pk
              description: Test if claim_id + line_number + transaction_date is a true primary key (Assumes transactional data).
              query: |
                SELECT COUNT(*) as should_be_zero
                FROM (
                  SELECT [claim_id_field], [line_number_field], [transaction_date_field]
                  FROM my_claims_table
                  GROUP BY [claim_id_field], [line_number_field], [transaction_date_field]
                  HAVING COUNT(*) > 1
                ) subquery;
            - name: check_duplicate_content
              description: If not a PK, test if duplicates are pure duplicates (all other relevant columns identical).
              query: |
                SELECT COUNT(*) as should_be_zero
                FROM (
                  SELECT [claim_id_field], [line_number_field], [transaction_date_field], MIN([paid_amount_field]) as min_pmt, MAX([paid_amount_field]) as max_pmt -- Add other MIN/MAX pairs as needed
                  FROM my_claims_table
                  GROUP BY [claim_id_field], [line_number_field], [transaction_date_field]
                  HAVING MIN([paid_amount_field]) <> MAX([paid_amount_field]) -- Check other fields similarly
                     OR MIN(some_other_field) <> MAX(some_other_field) -- etc.
                ) subquery;

    - step: identify_provider_information
      goal: Locate different provider roles and their identifiers.
      checks:
        - check: Identify available provider fields (billing_npi/tin, rendering_npi, service_npi, attending_npi, operating_npi, facility_id, pcp_npi).
        - check: Determine identifier types used (NPI, TIN, CCN, other). Verify NPI format (10 digits).
        - check: Assess population consistency of roles across Institutional vs. Professional claims. (Billing provider should usually be present).

    - step: understand_financial_fields
      goal: Identify key financial amounts and understand their context.
      checks:
        - check: Locate core financial fields (plan_paid, allowed_amount, patient_responsibility, charged_amount).
        - check: Check for patient responsibility components (deductible, coinsurance, copay).
        - check: Determine location of financials (header vs. line) based on claim type patterns.
          - Institutional: Often header-level; assess if line amounts are real or bundled/duplicated. Look for flags/patterns.
          - Professional: Typically line-level.
        - check: Note presence and context of negative paid amounts (transactional or data issues).

    - step: assess_data_quality_and_consistency
      goal: Identify potential issues early.
      checks:
        - check: Profile null percentages in critical fields (IDs, dates, codes, amounts).
        - check: Validate coded values against expected formats/sets (ICD, TOB, POS). Check for non-standard codes.
        - check: Check date logic (Service End >= Service Start, Line Dates within Header Dates).
        - check: Look for signs of file corruption / shifted columns.
        - check: Assess internal consistency (financials add up, flags align with codes).
        - check: Check for claims without contemporaneous membership.

    - step: understand_data_generating_process_revisited
      goal: Solidify understanding of how data arrives (transactional/final_action, incremental/restated).
      checks:
        - check: Synthesize findings from transactionality, identifiers, and date patterns to classify DGP.
        - check: If restated, determine if it's full or partial (e.g., "current state only").
        - check: If restated, determine how reversals/deletions are handled (explicit transaction vs. silent disappearance). This impacts LT strategy (simple dedup vs. "Cadillac" restatement logic).
        - check: Note if different claim types follow different DGPs within the same file.
